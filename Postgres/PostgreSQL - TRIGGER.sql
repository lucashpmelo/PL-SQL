CREATE OR REPLACE FUNCTION FUN_SECURE_EMP() RETURNS TRIGGER
AS
$$
BEGIN
	IF TO_CHAR(CURRENT_TIMESTAMP, 'HH24:MI') NOT BETWEEN '08:00' AND '10:00' THEN
		RAISE EXCEPTION 'NÃO PODE INSERIR DADOS NESSE HORARIO';
	END IF;
	RETURN NEW;
END;
$$LANGUAGE PLPGSQL;

CREATE TRIGGER SECURE_EMP
BEFORE INSERT ON REGIONS
    FOR EACH ROW EXECUTE PROCEDURE FUN_SECURE_EMP();

-----------------------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION FUN_SECURE_EMP() RETURNS TRIGGER
AS
$$
BEGIN
	IF TO_CHAR(CURRENT_TIMESTAMP, 'HH24:MI') NOT BETWEEN '08:00' AND '10:00' THEN
		IF TG_OP = 'INSERT' THEN
			RAISE EXCEPTION 'NÃO PODE INSERIR DADOS NESSE HORARIO';
		ELSIF TG_OP = 'UPDATE' THEN
			RAISE EXCEPTION 'NÃO PODE ATUALIZAR DADOS NESSE HORARIO';
		ELSIF TG_OP = 'DELETE' THEN
			RAISE EXCEPTION 'NÃO PODE DELETAR DADOS NESSE HORARIO';
		END IF;		
	END IF;
	RETURN NEW;
END;
$$LANGUAGE PLPGSQL;

CREATE TRIGGER SECURE_EMP
BEFORE INSERT OR UPDATE OR DELETE ON REGIONS
    FOR EACH ROW EXECUTE PROCEDURE FUN_SECURE_EMP();
	
-----------------------------------------------------------------------------------------------------------------

SELECT * INTO TB_LOG_EMPLOYEES FROM EMPLOYEES WHERE EMPLOYEE_ID = -1;

ALTER TABLE TB_LOG_EMPLOYEES ADD COLUMN USUARIO TEXT;
ALTER TABLE TB_LOG_EMPLOYEES ADD COLUMN DATA DATE;

CREATE OR REPLACE FUNCTION FUN_LOG_EMPLOYEES() RETURNS TRIGGER
AS
$$
BEGIN
	INSERT INTO TB_LOG_EMPLOYEES VALUES(OLD.EMPLOYEE_ID, OLD.FIRST_NAME, OLD.LAST_NAME, OLD.EMAIL, OLD.PHONE_NUMBER, OLD.HIRE_DATE, OLD.JOB_ID, OLD.SALARY, OLD.COMMISSION_PCT, OLD.MANAGER_ID, OLD.DEPARTMENT_ID, USER, CURRENT_TIMESTAMP);
	
	RETURN NEW;
END;
$$LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_LOG_EMPLOYEES
AFTER INSERT OR UPDATE OR DELETE ON EMPLOYEES
    FOR EACH ROW EXECUTE PROCEDURE FUN_LOG_EMPLOYEES();
	
-----------------------------------------------------------------------------------------------------------------

/*
Manager
1) CRIAR UMA FUNÇÃO CHECK_SALARY QUE RECEBE DOIS PARAMETROS JOB E O SALARIO E RETORNA VERDADEIRO OU FALSO
	(SE SALARIO ESTIVER NA FAIXA PERMITIDA RETORNA TRUE CASO CONTRARIO RETORNA FALSE)
	VAI VERIFICAR NA TABELA JOBS SE O SALARIO ESTA ENTRE OS VALORES MINIMO E MAXIMO,
	CASO ESTEJA FORA DESTA FAIXA RETORNAR FALSO; TRATAR POSSIVEIS ERROS.

    CRIAR UMA TRIGGER NA TABELA EMPLOYEES, PARA CADA LINHA, NA INSERÇÃO OU ALTERAÇÃO CHAMAR A FUNÇÃO CHECK_SALARY,
	PASSANDO O NOVO JOB E O NOVO SALARIO, CASO RETORNE FALSO DA FUNÇÃO DEVERÁ SER GERADO UM ERRO.
	A TRIGGER DEVERÁ EXECUTAR ANTES DA INSERÇÃO OU ALTERAÇÃO. 


	- usando a procedure add_employee adicionar o funcionario First_name=Eleanor, 
          last_name = beh, e_mail=ebeh, job_id= IT_PROG SAL=5000

	- alterar o salario do funcionario com id 115 para 2000
*/

CREATE OR REPLACE FUNCTION CHECK_SALARY( JOB JOBS.JOB_ID%TYPE, SALARIO JOBS.MIN_SALARY%TYPE) RETURNS BOOLEAN
AS
$$
DECLARE
	FLAG BOOLEAN;
	CONT INT;
BEGIN
	IF JOB IS NULL OR SALARIO IS NULL THEN
		RAISE EXCEPTION USING ERRCODE = 'NNULL';
	END IF;
	
	SELECT COUNT(*) INTO CONT FROM JOBS WHERE JOB_ID = JOB AND SALARIO BETWEEN MIN_SALARY AND MAX_SALARY;
	
	IF CONT = 0 THEN
		FLAG := FALSE;
	ELSE
		FLAG := TRUE;
	END IF;
	
	RETURN FLAG;
EXCEPTION
	WHEN SQLSTATE 'NNULL' THEN
    	RAISE NOTICE 'JOB OU SALARIO NÃO PODE SER NULL!!!';
	WHEN OTHERS THEN
		RAISE NOTICE 'ERRO!!!';
END;
$$LANGUAGE PLPGSQL

CREATE OR REPLACE FUNCTION FUN_NEWSALARIO() RETURNS TRIGGER
AS
$$
BEGIN
	IF NOT CHECK_SALARY(NEW.JOB_ID, NEW.SALARY) THEN
		RAISE EXCEPTION 'ESTA FORA DA FAIXA SALARIAL!!!';
	END IF;
	
	RETURN NEW;
END;
$$LANGUAGE PLPGSQL


CREATE TRIGGER TRI_NEWSALARIO
BEFORE INSERT OR UPDATE OF SALARY ON EMPLOYEES
    FOR EACH ROW EXECUTE PROCEDURE FUN_NEWSALARIO();
	
-----------------------------------------------------------------------------------------------------------------

/*
2) ESCREVER UMA TRIGGER CHAMADA TRG_DELETE_EMP PARA PERMITIR DELETAR UM EMPREGADO APENAS NO HORARIO DE TRABALHO.
	A) PERMITIR DELETAR APENAS NOS DIAS DA SEMANA ENTRE SEGUNDA  E SEXTA FEIRA.
	B) PERMITIR APENAS DELETAR NO HORARIO COMERCIAL (8:00 AS 18:00 HORAS)

PARA VERIFICAR DIAS DA SEMANA:
	DIA VARCHAR2(3) := TO_CHAR(SYSDATE, 'DY');
	
PARA VERIFICAR A HORA:
	HORA PLS_INTEGER := TO_NUMBER(TO_CHAR(SYSDATE, 'HH24'));

 PARA TESTAR: DELETE FROM EMPLOYEES WHERE JOB_ID ='SA_REP' AND DEPARTMENT_ID IS NULL
 */
 
CREATE OR REPLACE FUNCTION FUN_DELETE_EMP() RETURNS TRIGGER
AS
$$
BEGIN
	IF TO_CHAR(CURRENT_DATE, 'DY') NOT BETWEEN 'MON' AND 'FRI' AND TO_CHAR(CURRENT_TIMESTAMP, 'HH24:MI') BETWEEN '08:00' AND '18:00' THEN		
		RAISE EXCEPTION 'NÃO PODE DELETAR EMPREGADOS NESSE HORARIO';
	END IF;
	
	RETURN NEW;
END;
$$LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_DELETE_EMP
BEFORE DELETE ON EMPLOYEES
    FOR EACH ROW EXECUTE PROCEDURE FUN_DELETE_EMP();

-----------------------------------------------------------------------------------------------------------------

/*
3) ALTERAR A TRIGGER DO EXERCÍCIO 1 PARA EXECUTAR SOMENTE QUANDO:
	A) NOVO JOB_ID FOR DIFERENTE DO JOB_ID CADASTRADO.
	B) NOVO SALARIO FOR DIFERENTE DO SALARIO CADASTRADO.
       RESOLVER COM CLAUSULA WHEN NA TRIGER
	   
foi acrescentado or old.salary is null para resolver o problema de insert, devido
ao atributo salary estar nulo quando for inserção
when (new.salary <> old.salary or old.salary is null) and (new.job_id <> old.job_id or old.job_id is null)
*/

CREATE OR REPLACE FUNCTION FUN_NEWSALARIO() RETURNS TRIGGER
AS
$$
BEGIN
	IF (NEW.JOB_ID <> OLD.JOB_ID OR OLD.JOB_ID IS NULL) OR (NEW.SALARY <> OLD.SALARY OR OLD.SALARY IS NULL) THEN	-- "CLAUSULA WHEN" --
		IF NOT CHECK_SALARY(NEW.JOB_ID, NEW.SALARY) THEN
			RAISE EXCEPTION 'ESTA FORA DA FAIXA SALARIAL!!!';
		END IF;
	END IF;
	
	RETURN NEW;
END;
$$LANGUAGE PLPGSQL